# 选择排序

## 算法描述

选择排序是一种简单直观的排序算法。它的基本思想是从待排序的元素中选择最小（或最大）的元素，然后将其放到已排序序列的末尾（或开头）。通过重复这个过程，直到所有元素都被排序。

具体步骤如下：

1. 首先，从待排序序列中找到最小（或最大）的元素。
2. 将找到的最小（或最大）元素与待排序序列的第一个元素交换位置，将其放到已排序序列的末尾（或开头）。
3. 然后，将待排序序列缩小一个元素，即将已排序序列的长度增加一个元素。
4. 重复步骤1到步骤3，直到待排序序列为空。

选择排序的关键点在于每次选择最小（或最大）元素的过程，这样可以确保每次选择的元素都是当前待排序序列中最小（或最大）的元素。通过不断缩小待排序序列的范围，最终实现整个序列的排序。

选择排序是一种不稳定的排序算法，因为在交换元素的过程中，可能改变相同元素的相对顺序。它的时间复杂度为 $O(n^2)$ ，其中 $n$ 是待排序序列的长度。尽管选择排序的效率相对较低，但它的实现简单，对于小规模的数据排序是一种不错的选择。

## 编程实现

下面是使用C语言实现选择排序的示例代码：

```c
#include <stdio.h>

// 选择排序函数
void selectionSort(int arr[], int n) {
    int i, j, minIndex, temp;
    for (i = 0; i < n - 1; i++) {
        minIndex = i;
        for (j = i + 1; j < n; j++) {
            // 找到最小元素的索引
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 将最小元素与当前位置交换
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}

// 打印数组函数
void printArray(int arr[], int n) {
    int i;
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 测试代码
int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("原始数组：");
    printArray(arr, n);

    selectionSort(arr, n);

    printf("排序后数组：");
    printArray(arr, n);

    return 0;
}
```

在上述示例代码中，我们定义了一个 `selectionSort` 函数来实现选择排序。选择排序的基本思想是每次从未排序的部分中选择最小的元素，然后将其与未排序部分的第一个元素交换位置，重复这个过程直到整个数组排序完成。

在 `main` 函数中，我们创建了一个示例的整数数组 `arr`，并通过调用 `selectionSort` 函数对数组进行排序。最后，我们使用 `printArray` 函数打印排序后的数组。

输出结果将会是：

```
原始数组：64 25 12 22 11
排序后数组：11 12 22 25 64
```

请注意，选择排序的时间复杂度为 $O(n^2)$ ，其中 $n$ 是数组的大小。虽然选择排序简单易实现，但在大规模数据排序时效率较低，不适用于大型数据集。
